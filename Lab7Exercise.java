public class Lab7Exercise{

    /**
     * Άσκηση 1: Περιγράψτε την έννοια της ισοτιμίας και δημιουργείστε κώδικα, που να υπολογίζει άρτια ισοτιμία 
     * για ένα μήνυμα των 14 bits και να προσαρτά σε αυτό ένα bit ισοτιμίας.
     * 
     * Λειτουργία: Υπολογίζει την άρτια ισοτιμία του δυαδικού μηνύματος που δίνεται ως όρισμα (κωδικοποιημένο σε
     * συμβολοσειρά με χαρακτήρες '0' ή '1' αντί των δυαδικών αριθμών 0 ή 1), προσαρτά το bit ισοτιμίας στο μήνυμα
     * αυτό και επιστρέφει το συνολικό μήνυμα (δοθέν με προσαρτημένο στο τέλος το bit ισοτιμίας).
     * 
     * @param message το μήνυμα για το οποίο πρέπει να υπολογιστεί και στο οποίο πρέπει να προσαρτηθεί το bit
     *                άρτιας ισοτιμίας.
     * @return το μήνυμα ορίσματος με προσαρτημένο το bit ισοτιμίας (κωδικοποιημένα σε συμβολοσειρά).
     */
    public static String generateEvenParity(String message){
        int numberOfOnes = 0; // Αποθηκεύει τον αριθμό των δυαδικών ψηφίων 1 υπάρχουν στο μήνυμα.

        // Μέτρηση ψηφίων 1 στο μήνυμα.
        for (int i = 0; i < message.length(); i++){
            // Άν το τρέχον bit του μηνύματος είναι 1, το μετράω.
            if (message.charAt(i) == '1'){
                numberOfOnes++;
            }
        }

        char parityBit; // Αποθηκεύει το ψηφίο ισοτιμίας.
        // Έλεγχος αν ο αριθμός των 1 είναι άρτιος (πληρείται η άρτια άρτια ισοτιμία)
        // τότε ο αριθμός των 1 πρέπει να διαιρείται με το 2 με υπόλοιπο 0.
        if (numberOfOnes % 2 == 0){
            // Σε αυτή την περίπτωση για να διασφαλιστεί η άρτια ισοτιμία
            // προσαρτούμε 0 ώστε το πλήθος των 1 να παραμείνει άρτιος.
            parityBit = '0';
        } else {
            // Σε αυτή την περίπτωση για να διασφαλιστεί η άρτια ισοτιμία
            // προσαρτούμε 1 ώστε το πλήθος των 1 να γίνει άρτιος.
            parityBit = '1';
        }

        // Προσαρτώ το κατάλληλο bit ισοτιμίας και επιστρέφω την τελική ακολουθία bit.
        return message + parityBit;
    }

    /**
     * Άσκηση 2: Δημιουργείστε κώδικα που να ελέγχει αν υπάρχει σφάλμα σε ένα bit για το μήνυμα
     * των 14 bits που συνοδεύεται από ένα bit άρτιας ισοτιμίας. 
     * 
     * Λειτουργία: Ελέγχει αν υπάρχει σφάλμα σε ένα bit (ή γενικότερα σε περιττό αριθμό bits) για 
     * το δυαδικό μήνυμα που συνοδεύεται με bit άρτια ισοτιμίας που δίνεται ως όρισμα (κωδικοποιημένο
     * σε συμβολοσειρά με χαρακτήρες '0' ή '1' αντί των δυαδικών αριθμών 0 ή 1) και επιστρέφει λογική 
     * τιμή που περιγράφει την ορθότητα του μηνύματος ως προς την άρτια ισοτιμία.
     * 
     * @param message το μήνυμα που ακολουθείται από bit άρτιας ισοτιμίας το οποίο πρέπει να ελεγχθεί 
     *                ως προς σφάλματα άρτιας ισοτιμίας.
     * @return τιμή που περιγράφει την ορθότητα του μηνύματος ως προς την άρτια ισοτιμία. true σε περίπτωση
     *         όπου δεν εντοπίστηκαν σφάλματα ισοτιμίας, false σε διαφορετική περίπτωση.
     */
    public static boolean checkEvenParity(String message){
        // Η διαδικασία είναι όμοια με την παραγωγή του bit άρτιας ισοτιμίας με την διαφορά ότι
        // σε αυτή την περίπτωση ελέγχεται αν πληρείται η άρτια ισοτιμία στο μήνυμα, ενώ στην
        // παραγωγή δημιουργείται κατάλληλο bit ώστε η συνολική ακολουθία bits (που περιλαμβάνει το μήνυμα
        // με προσαρτημένο το bit ισοτιμίας) να πληροί άρτια ισοτιμία.

        int numberOfOnes = 0; // Αποθηκεύει τον αριθμό των δυαδικών ψηφίων 1 υπάρχουν στο μήνυμα.

        // Μέτρηση ψηφίων 1 στο μήνυμα.
        for (int i = 0; i < message.length(); i++){
            // Άν το τρέχον bit του μηνύματος είναι 1, το μετράω.
            if (message.charAt(i) == '1'){
                numberOfOnes++;
            }
        }

        // Άν ο αριθμός των 1 στην ακολουθία είναι άρτιος (πληρείται η άρτια άρτια ισοτιμία)
        // τότε ο αριθμός των 1 διαιρείται με το 2 με υπόλοιπο 0. Επιστρέφω λογική τιμή για το αν συμβαίνει αυτό. 
        return numberOfOnes % 2 == 0;
    }

    /**
     * Άσκηση 3: Δημιουργείστε κώδικα που να διαιρεί ένα μήνυμα των 28 bits σε 4 γραμμές των 7 bits,
     * να υπολογίζει τα bits άρτιας δισδιάστατης ισοτιμίας για κάθε γραμμή και κάθε στήλη και 
     * να τα προσαρτά σε αυτές. 
     * 
     * Λειτουργία: Δέχεται ένα μήνυμα των 28bits, το διαιρεί σε 4 τμήματα των 7 bits, αντιστοιχεί αυτά τα τμήματα
     * σε δισδιάστατο πίνακα, παράγει bits άρτιας δισδιάστατης ισοτιμίας και επιστρέφει μία ακολουθία 40 bits η οποία
     * σχηματίζεται αν συνενώσουμε κάθε γραμμή του πλήρη πίνακα (που δημιουργείται προσαρτώντας τα bits άρτιας ισοτιμίας για κάθε γραμμή 
     * και στήλη στον δισδιάστατο πίνακα) σε μία, ενιαία, ακολουθία από bit.
     * 
     * @param message το μήνυμα των 28 bits για το οποίο πρέπει να παραχθεί η δισδιάστατη άρτια ισοτιμία.
     * @return ο δισδιάστατος πίνακας (αποτελούμενος από bits μηνύματος με προσαρτημένα bits ισοτιμίας) ως μία συνεχόμενη ακολουθία
     * των 40bits.
     */
    public static String generateTwoDimensionalEvenParity(String message){
        char[][] parityArray = new char[5][8];

        // "Δείκτης" της θέσης του ψηφίου του μηνύματος που θα επεξεργαστώ στην συνέχεια.
        int bitIterator = 0; 

        // Κατασκευή του πίνακα ανά γραμμή με παράλληλη μέτρηση ψηφίων 1 για
        // υπολογισμό bit ισοτιμίας της γραμμής.
        for (int i = 0; i < 4; i++){ // Διάσχιση πίνακα κατά γραμμή 
            // Μετρητής ψηφίων 1.
            int numberOfOnes = 0;

            for (int j = 0; j < 7; j++){ // Διάσχιση γραμμής
                parityArray[i][j] = message.charAt(bitIterator++); // Τοποθέτηση ψηφίου στην κατάλληλη θέση

                // Μέτρηση ψηφίου 1, αν βρεθεί.
                if (parityArray[i][j] == '1' ){
                    numberOfOnes++;
                }
            }

            // Το τελευταίο στοιχείο της γραμμής έχει ως τιμή το bit ισοτιμίας της γραμμής.
            // Αν το πλήθος των δυαδικών ψηφίων 1 της γραμμής διαιρείται ακριβώς με το 2, τότε για να
            // εξασφαλιστεί άρτια ισοτιμία (άρτιο πλήθος ψηφίων 1) πρέπει να τοποθετηθεί ψηφίο ισοτιμίας 0
            // (για να μην μεταβληθεί το πλήθος των 1). 
            // Διαφορετικά, το ψηφίο ισοτιμίας θα πρέπει να είναι το 1.
            // Έτσι, το υπολογίζω και το τοποθετώ στην τελευταία θέση της γραμμής.
            parityArray[i][7] = numberOfOnes%2==0?'0':'1';
        }

        // Υπολογισμός bits ισοτιμίας των στηλών.
        for (int j = 0; j <= 7; j++){ // Διάσχιση πίνακα κατά στήλη. 
            // Μετρητής ψηφίων 1.
            int numberOfOnes = 0;
            
            for (int i = 0; i < 4; i++){ // Διάσχιση στήλης
                // Μέτρηση ψηφίου 1, αν βρεθεί.
                if (parityArray[i][j] == '1' ){
                    numberOfOnes++;
                }
            }

            // Υπολογίζω και τοποθετώ το bit ισοτιμίας της κάθε στήλης
            // στην κατάλληλη θέση της τελευταίας γραμμής.
            parityArray[4][j] = numberOfOnes%2==0?'0':'1';
        }

        StringBuilder result = new StringBuilder();

        // Μετατροπή πίνακα σε ακολουθία bits με διάσχιση του
        // ανά γραμμή και προσάρτησης της τιμής κάθε στοιχείου δίπλα στην προηγούμενη.
        for (int i = 0; i <= 4; i++){
            for (int j = 0; j <= 7; j++){
                result.append(parityArray[i][j]);   
            }
        }

        // Επιστροφή αποτελέσματος.
        return result.toString();
    }

    /**
     * Άσκηση 4: Δημιουργείστε κώδικα που να ανιχνεύει σφάλματα στον 
     * πίνακα δύο διαστάσεων (αποτελούμενο από bits μηνύματος και bits ισοτιμίας).
     * 
     * Λειτουργία: ανασυγκροτεί τον πίνακα δύο διαστάσεων των bit μηνύματος
     * και ισοτιμίας χωρίζοντας το μήνυμα μήκους 40 bit σε τμήματα των 8 bit όπου το
     * κάθε ένα αποτελεί γραμμή ενός 5x8 πίνακα. Στην συνέχεια εξετάζει τα bits 
     * της άρτιας ισοτιμίας που ελέγχουν κάθε στήλη και γραμμή του πίνακα.
     * 
     * @param message μήνυμα μήκους 40 bits όπου κάθε τμήμα 8 bits αντιστοιχεί σε μία
     * γραμμή του δισδιάστατου (5x8) πίνακα (αποτελούμενο από bits μηνύματος και bits άρτιας ισοτιμίας)
     * @return Τιμή που περιγράφει την ορθότητα του μηνύματος ως προς την άρτια ισοτιμία. true σε περίπτωση
     *         όπου δεν εντοπίστηκαν σφάλματα ισοτιμίας, false σε διαφορετική περίπτωση.
     */
    public static boolean checkTwoDimensionalEvenParity(String message){
        char[][] parityArray = new char[5][8];

        // "Δείκτης" της θέσης του ψηφίου του μηνύματος που θα επεξεργαστώ στην συνέχεια.
        int bitIterator = 0; 
        
        
        // Ανασυγκρότηση του πίνακα ανά γραμμή.
        for (int i = 0; i <= 4; i++){ // Διάσχιση πίνακα κατά γραμμή 
            for (int j = 0; j <= 7; j++){ // Διάσχιση γραμμής
                parityArray[i][j] = message.charAt(bitIterator++); // Τοποθέτηση ψηφίου στην κατάλληλη θέση
            }
        }

        // Έλεγχος των bit ισοτιμίας των γραμμών.
        for (int i = 0; i < 4; i++){ // Διάσχιση πίνακα κατά γραμμή 
            // Μετρητής ψηφίων 1.
            int numberOfOnes = 0;

            for (int j = 0; j < 7; j++){ // Διάσχιση γραμμής
                // Μέτρηση ψηφίου 1, αν βρεθεί.
                if (parityArray[i][j] == '1' ){
                    numberOfOnes++;
                }
            }
            
            // Υπολογισμός bit άρτιας ισοτιμίας γραμμής για αργότερη σύγκριση του με αυτό που λήφθηκε.
            char rowParity = numberOfOnes%2==0?'0':'1';

            // Έλεγχος ισοτιμίας γραμμής: Αν έστω και για μία γραμμή το bit ισοτιμίας που υπολογίζεται διαφέρει αυτού που
            // λήφθηκε τότε υπάρχει σφάλμα και επιστρέφω false.
            if (rowParity != parityArray[i][7]){
                return false;
            }
        }

        // Έλεγχος bits ισοτιμίας των στηλών.
        for (int j = 0; j <= 7; j++){ // Διάσχιση πίνακα κατά στήλη. 
            // Μετρητής ψηφίων 1.
            int numberOfOnes = 0;
            
            for (int i = 0; i < 4; i++){ // Διάσχιση στήλης
                // Μέτρηση ψηφίου 1, αν βρεθεί.
                if (parityArray[i][j] == '1' ){
                    numberOfOnes++;
                }
            }
            
            // Υπολογισμός bit άρτιας ισοτιμίας στήλης για αργότερη σύγκριση του με αυτό που λήφθηκε.
            char colParity = numberOfOnes%2==0?'0':'1';


            // Έλεγχος ισοτιμίας στήλης: Αν έστω και για μία στήλη το bit ισοτιμίας που υπολογίζεται διαφέρει αυτού που
            // λήφθηκε τότε υπάρχει σφάλμα και επιστρέφω false.
            if (colParity != parityArray[4][j]){
                return false;
            }
        }

        // Δεν βρέθηκε κάποιο σφάλμα στους επιμέρους ελέγχους, επιστρέφω true.
        return true;
    }

    /**
     * Υπολογίζει τα αποτελέσματα των ασκήσεων χρησιμοποιώντας τις παραπάνω μεθόδους.
     * @param args ορίσματα κονσόλας, δεν χρησιμοποιούνται.
     */
    public static void main(String[] args) {
        String message; // Χρησιμοποιείται στην αποθήκευση ορισμάτων.
        String resultString; // Χρησιμοποιείται στην αποθήκευση αποτελεσμάτων (τύπου String).
        boolean resultBoolean; // Χρησιμοποιείται στην αποθήκευση αποτελεσμάτων (τύπου boolean).

        /*
         * 1) Περιγράψτε την έννοια της ισοτιμίας και δημιουργείστε κώδικα, που να υπολογίζει άρτια ισοτιμία για 
         *    ένα μήνυμα των 14 bits και να προσαρτά σε αυτό ένα bit ισοτιμίας. 
         * 
         *    Τρέξτε τον κώδικά σας για το μήνυμα 10001101011000.
         * 
         *    Αυτό πραγματοποιείται με την βοήθεια της μεθόδου generateEvenParity με όρισμα την ακολουθία "10001101011000".
         */
         System.out.println("Άσκηση 1 - Αποτέλεσμα:");
         message = "10001101011000";
         resultString = generateEvenParity(message);
         System.out.printf("\t Bit άρτιας ισοτιμίας του μηνύματος \"10001101011000\" είναι: %c, με τελικό μήνυμα: %s%n%n", 
                            resultString.charAt(resultString.length()-1), resultString);

        /*
         * 2)  Δημιουργείστε κώδικα που να ελέγχει αν υπάρχει σφάλμα σε ένα bit για το μήνυμα των 14 bits που συνοδεύεται 
         * από ένα bit άρτιας ισοτιμίας. 
         * 
         * Τρέξτε τον κώδικά σας για να ελέγξετε το αν έχει φτάσει χωρίς σφάλμα το μήνυμα 10001101011000 του προηγούμενου 
         * σκέλους της άσκησης (και το bit ισοτιμίας που το συνοδεύει) στις εξής περιπτώσεις:
         *  i. Άφιξη στον αποδέκτη χωρίς σφάλμα.
         *  ii. Άφιξη στον αποδέκτη με ένα σφάλμα (στο 6ο bit, με αρίθμηση των bit μετρώντας από αριστερά).
         *  iii. Άφιξη στον αποδέκτη με δύο σφάλματα (στο 6ο bit και στο 12ο bit, με αρίθμηση των bit μετρώντας από αριστερά).
         * 
         *  Αυτό πραγματοποιείται με την βοήθεια της μεθόδου checkEvenParity με κατάλληλα ορίσματα.
         */
        System.out.println("Άσκηση 2 - Αποτέλεσμα:");
        System.out.println("\t (Σημείωση: ο έλεγχος σφάλματος δίνει αποτέλεσμα \"false\" όταν εντοπίζονται σφάλματα άρτιας ισοτιμίας, διαφορετικά δίνει \"true\".)");

        // Περίπτωση i.
        // Το μήνυμα "10001101011000" έχει 6 ψηφία 1 οπότε έχει bit άρτιας ισοτιμίας 0 με συνολικό μήνυμα
        // το "100011010110000"
        message = "100011010110000";
        resultBoolean = checkEvenParity(message);
        System.out.printf("\t   i. Άφιξη στον αποδέκτη χωρίς σφάλμα: Αποτέλεσμα ελέγχου: %b%n", resultBoolean);

        // Περίπτωση ii.
        // Στο μήνυμα "100011010110000" εμφανίζεται σφάλμα στο 6ο bit (με αρίθμηση bit απο τα αριστερά) 
        // και μετατρέπεται στο "100010010110000"
        message = "100010010110000";
        resultBoolean = checkEvenParity(message);
        System.out.printf("\t  ii. Άφιξη στον αποδέκτη με ένα σφάλμα: Αποτέλεσμα ελέγχου: %b%n", resultBoolean);

        // Περίπτωση iii.
        // Στο μήνυμα "100011010110000" εμφανίζεται σφάλμα στο 6ο και στο 12ο bit (με αρίθμηση bit απο τα αριστερά) 
        // και μετατρέπεται στο "100010010111000"
        message = "100010010111000";
        resultBoolean = checkEvenParity(message);
        System.out.printf("\t iii. Άφιξη στον αποδέκτη με δύο σφάλματα: Αποτέλεσμα ελέγχου: %b%n", resultBoolean);
        System.out.println();


        /*
         * 3) Δημιουργείστε κώδικα που να διαιρεί ένα μήνυμα των 28 bits σε 4 γραμμές των 7 bits 
         * (όπως φαίνεται στο σχήμα), να υπολογίζει τα bits άρτιας δισδιάστατης ισοτιμίας για κάθε 
         * γραμμή και κάθε στήλη και να τα προσαρτά σε αυτές. 
         * 
         * Αυτά πραγματοποιούνται από την συνάρτηση generateTwoDimensionalEvenParity με όρισμα
         * το δυαδικό μήνυμα των 28 bits "1100111101110101110010101001"
         */

        message = "1100111101110101110010101001";
        resultString = generateTwoDimensionalEvenParity(message);
        System.out.println("Άσκηση 3 - Αποτέλεσμα:");
        // Εκτύπωση μηνύματος
        System.out.printf("\t Το αποτέλεσμα είναι: %s%n",resultString);
        System.out.println();

        /*
         * 4) Δημιουργείστε κώδικα που να ανιχνεύει σφάλματα στον πίνακα δύο διαστάσεων (αποτελούμενο από bits μηνύματος 
         * και bits ισοτιμίας) που παράγεται από τον κώδικα του 3ου σκέλους της άσκησης. 
         *    Τρέξτε τον κώδικά σας για το συγκεκριμένο μήνυμα του 3ου σκέλους της άσκησης και για τις εξής περιπτώσεις:
         *    i. Ο πίνακας φτάνει χωρίς σφάλματα
         *    ii. Ο πίνακας φτάνει με σφάλματα σε ένα bit (στο συγκεκριμένο bit που φαίνεται με γαλάζιο χρώμα στο σχήμα b).
         *    iii. Ο πίνακας φτάνει με σφάλμα σε δύο bits (στα συγκεκριμένα bits που φαίνονται με γαλάζιο χρώμα στο σχήμα c).
         * 
         * Αυτά πραγματοποιούνται από την συνάρτηση checkTwoDimensionalEvenParity με κατάλληλα ορίσματα.
         */
        System.out.println("Άσκηση 4 - Αποτέλεσμα:");
        System.out.println("\t (Σημείωση: ο έλεγχος σφάλματος δίνει αποτέλεσμα \"false\" όταν εντοπίζονται σφάλματα άρτιας ισοτιμίας, διαφορετικά δίνει \"true\".)");
        
        // Περίπτωση i.
        // Η 3η άσκηση παράγει ως αποτέλεσμα την ακολουθία (δισδιάστατο πίνακα) 40 bits "1100111110111011011100100101001101010101".
        message = "1100111110111011011100100101001101010101";
        resultBoolean = checkTwoDimensionalEvenParity(message);
        System.out.printf("\t   i. Ο πίνακας φτάνει χωρίς σφάλματα: Αποτέλεσμα ελέγχου: %b%n", resultBoolean);
        
        // Περίπτωση ii.
        // Υπάρχει σφάλμα στο bit 2ης γραμμής και 3ης στήλης. Δηλαδή αλλάζει το 11ο bit της ακολουθίας των 40 bits με
        // αποτέλεσμα "1100111110011011011100100101001101010101".
        message = "1100111110011011011100100101001101010101";
        resultBoolean = checkTwoDimensionalEvenParity(message);
        System.out.printf("\t  ii. Ο πίνακας φτάνει με σφάλματα σε ένα bit: Αποτέλεσμα ελέγχου: %b%n", resultBoolean);

        // Περίπτωση iii.
        // Υπάρχει σφάλμα στο bit 2ης γραμμής και 3ης στήλης και σε εκείνο της ίδιας γραμμής και 5ης στήλης. 
        // Δηλαδή αλλάζει το 11ο bit της ακολουθίας των 40 bits με αποτέλεσμα "1100111110010011011100100101001101010101".
        message = "1100111110010011011100100101001101010101";
        resultBoolean = checkTwoDimensionalEvenParity(message);
        System.out.printf("\t iii. Ο πίνακας φτάνει με σφάλμα σε δύο bits: Αποτέλεσμα ελέγχου: %b%n", resultBoolean);

   }
}
